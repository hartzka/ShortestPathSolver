<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AStar.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ShortestPathSolver</a> &gt; <a href="index.source.html" class="el_package">com.shortestpathsolver.algorithms</a> &gt; <span class="el_source">AStar.java</span></div><h1>AStar.java</h1><pre class="source lang-java linenums">package com.shortestpathsolver.algorithms;

import com.shortestpathsolver.domain.Node;
import com.shortestpathsolver.domain.ShortestRoute;
import com.shortestpathsolver.structures.CustomArrayList;
import com.shortestpathsolver.structures.Heap;
import com.shortestpathsolver.structures.Pair;

/**
 * A*-algorithm
 *
 * @author kaihartz
 */
public class AStar extends Algorithm {

<span class="fc" id="L16">    private int hCost = 10;</span>
<span class="fc" id="L17">    private int diagonalCost = 14;</span>
    private Heap openList;
    private CustomArrayList&lt;Node&gt; closedSet;
    private ShortestRoute sr;
    private boolean jps; //JPS-algorithm

    public AStar(ShortestRoute sr) {
<span class="fc" id="L24">        super(sr);</span>
<span class="fc" id="L25">        this.sr = sr;</span>
<span class="fc" id="L26">        this.jps = false;</span>
<span class="fc" id="L27">        this.openList = new Heap();</span>
<span class="fc" id="L28">        this.closedSet = new CustomArrayList&lt;&gt;();</span>
<span class="fc" id="L29">    }</span>

    /**
     * The main logic in A* algorithm. Checks if currentNode's neighbour is
     * found in closed set and open list. Updates node's information and checks
     * if a better path exists from currentNode to its neighbour.
     *
     * @param currentNode Current node
     * @param col Neighbour's column
     * @param row Neighbour's row
     * @param cost Movement cost
     */
    private void checkNode(Node currentNode, int col, int row, int cost) {
<span class="fc" id="L42">        Node neighbour = sr.getNodes()[row][col];</span>
<span class="fc bfc" id="L43" title="All 2 branches covered.">        if (!neighbour.isBlock()) {</span>
<span class="fc bfc" id="L44" title="All 4 branches covered.">            if (!closedSet.contains(neighbour) &amp;&amp; !openList.contains(neighbour)) {</span>
<span class="fc" id="L45">                neighbour.setAStarInformation(currentNode, cost);</span>
<span class="fc" id="L46">                openList.add(neighbour);</span>
<span class="fc bfc" id="L47" title="All 2 branches covered.">            } else if (closedSet.contains(neighbour)) { // in case the algorithm doesn't work. Otherwise nodes in closed set shouldn't be processed.</span>
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">                if (checkifBetterPathExists(currentNode, neighbour, cost)) {</span>
<span class="nc" id="L49">                    openList.add(neighbour);</span>
                }
            } else {
<span class="fc" id="L52">                checkifBetterPathExists(currentNode, neighbour, cost);</span>
            }
        }
<span class="fc" id="L55">    }</span>

    /**
     * The main method, which searches the shortest route with either A* or JPS
     *
     * @param initialNode Beginning of the search
     * @return List presenting the route
     */
    @Override
    public CustomArrayList&lt;Node&gt; calculatePath(Node initialNode) {
<span class="fc" id="L65">        openList.add(initialNode);</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">        while (openList.size() != 0) {</span>
<span class="fc" id="L67">            Node currentNode = (Node) openList.poll(); // The node with smallest distance (f-value)</span>
<span class="fc" id="L68">            closedSet.add(currentNode);</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">            if (sr.isFinalNode(currentNode)) {</span>
<span class="fc" id="L70">                System.out.println(&quot;G: &quot; + currentNode.getG());</span>
<span class="fc" id="L71">                return getPath(currentNode);</span>
            } else {
<span class="fc bfc" id="L73" title="All 2 branches covered.">                if (!jps) {</span>
<span class="fc" id="L74">                    addNeighbourNodes(currentNode); //A*-algorithm</span>
                } else { //A* with JPS
<span class="fc" id="L76">                    Node[] jumpPoints = calculateJumpPoints(currentNode); //Possible jump points in JPS</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">                    for (int i = 0; i &lt; jumpPoints.length; i++) {</span>
<span class="fc" id="L78">                        Node jumpPoint = jumpPoints[i];</span>
<span class="pc bpc" id="L79" title="1 of 4 branches missed.">                        if (!(jumpPoint == null || jumpPoint.isBlock())) {</span>
<span class="fc bfc" id="L80" title="All 4 branches covered.">                            if (!closedSet.contains(jumpPoint) &amp;&amp; !openList.contains(jumpPoint)) { // Logic in JPS</span>
<span class="fc" id="L81">                                setAStarInformationRange(currentNode, jumpPoint);</span>
<span class="fc" id="L82">                                openList.add(jumpPoint);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">                            } else if (closedSet.contains(jumpPoint)) {</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">                                if (checkifBetterPathExists(currentNode, jumpPoint, approxG(currentNode.getColumn(), currentNode.getRow(), jumpPoint.getColumn(), jumpPoint.getRow()))) {</span>
<span class="fc" id="L85">                                    openList.add(jumpPoint);</span>
                                }
                            } else {
<span class="fc" id="L88">                                checkifBetterPathExists(currentNode, jumpPoint, approxG(currentNode.getColumn(), currentNode.getRow(), jumpPoint.getColumn(), jumpPoint.getRow()));</span>
                            }
                        }
                    }
                }
            }
<span class="fc" id="L94">        }</span>
<span class="fc" id="L95">        return new CustomArrayList&lt;&gt;();</span>
    }

    /**
     * Returns node's jumppoints for JPS. This speeds up the search remarkably.
     *
     * @param node
     * @return possible jump points
     */
    public Node[] calculateJumpPoints(Node node) {
<span class="fc" id="L105">        Node[] jumpPoints = new Node[8];</span>
<span class="fc" id="L106">        Pair[] neighbors = getNeighbours(node); // All neighbours</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">        for (int i = 0; i &lt; neighbors.length; i++) {</span>

<span class="fc" id="L109">            Pair&lt;Integer, Integer&gt; point = jump((int) neighbors[i].getKey(), (int) neighbors[i].getValue(), node.getColumn(), node.getRow()); //Pair presenting jump point</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">            if (point.getKey() != -1) {</span>
<span class="fc" id="L111">                int x = point.getKey();</span>
<span class="fc" id="L112">                int y = point.getValue();</span>

<span class="fc" id="L114">                int newG = (approxG(x, y, node.getColumn(), node.getRow()));</span>
<span class="fc bfc" id="L115" title="All 4 branches covered.">                if (sr.getNodes()[y][x].getDist() == 0 || sr.getNodes()[y][x].getG() &gt; newG) {</span>
<span class="fc" id="L116">                    jumpPoints[i] = sr.getNodes()[y][x]; // Jump point is added</span>
                }
            }
        }
<span class="fc" id="L120">        return jumpPoints;</span>
    }

    /**
     * Recursive method, which searches a jump point based on a node and its
     * parent.
     *
     * @param x node's column
     * @param y node's row
     * @param px parent's column
     * @param py parent's row
     * @return coordinates of the possibly found jump point
     */
    public Pair jump(int x, int y, int px, int py) {

<span class="fc" id="L135">        int dx = (x - px) / max(abs(x - px), 1);</span>
<span class="fc" id="L136">        int dy = (y - py) / max(abs(y - py), 1);</span>

<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (!allowed(x, y)) {</span>
<span class="fc" id="L139">            return new Pair(-1, -1);</span>
        }
<span class="fc bfc" id="L141" title="All 4 branches covered.">        if (x == sr.getFinalNode().getColumn() &amp;&amp; y == sr.getFinalNode().getRow()) {</span>
<span class="fc" id="L142">            return new Pair(x, y);</span>
        }
<span class="fc bfc" id="L144" title="All 4 branches covered.">        if (dx != 0 &amp;&amp; dy != 0) {</span>
<span class="fc bfc" id="L145" title="All 8 branches covered.">            if ((allowed(x - dx, y + dy) &amp;&amp; !allowed(x - dx, y)) || (allowed(x + dx, y - dy) &amp;&amp; !allowed(x, y - dy))) {</span>
<span class="fc" id="L146">                return new Pair(x, y);</span>
            }
<span class="fc" id="L148">            Pair jumpx = jump(x + dx, y, x, y);</span>
<span class="fc" id="L149">            Pair jumpy = jump(x, y + dy, x, y);</span>
<span class="fc bfc" id="L150" title="All 4 branches covered.">            if ((int) jumpx.getKey() != -1 || (int) jumpy.getKey() != -1) {</span>
<span class="fc" id="L151">                return new Pair(x, y);</span>
            }
<span class="fc" id="L153">        } else {</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">            if (dx == 0) {</span>
<span class="fc bfc" id="L155" title="All 8 branches covered.">                if ((allowed(x + 1, y + dy) &amp;&amp; !allowed(x + 1, y)) || (allowed(x - 1, y + dy) &amp;&amp; !allowed(x - 1, y))) {</span>
<span class="fc" id="L156">                    return new Pair(x, y);</span>
                }
            } else {
<span class="fc bfc" id="L159" title="All 8 branches covered.">                if ((allowed(x + dx, y + 1) &amp;&amp; !allowed(x, y + 1)) || (allowed(x + dx, y - 1) &amp;&amp; !allowed(x, y - 1))) {</span>
<span class="fc" id="L160">                    return new Pair(x, y);</span>
                }
            }
        }

<span class="pc bpc" id="L165" title="1 of 8 branches missed.">        if (x == 0 &amp;&amp; y == 0 &amp;&amp; dx == 0 &amp;&amp; dy == 0) {</span>
<span class="nc" id="L166">            return new Pair(-1, -1);</span>
        }
<span class="fc" id="L168">        Pair table = jump(x + dx, y + dy, x, y);</span>
<span class="fc" id="L169">        return table;</span>
    }

    /**
     * Returns all allowed node's neighbours
     *
     * @param node
     * @return table presenting neighbours
     */
    @Override
    public Pair[] getNeighbours(Node node) {
<span class="fc" id="L180">        Pair[] neighbors = new Pair[8];</span>
<span class="fc" id="L181">        int x = node.getColumn();</span>
<span class="fc" id="L182">        int y = node.getRow();</span>

<span class="fc bfc" id="L184" title="All 2 branches covered.">        neighbors[0] = allowed(x, y - 1) ? new Pair(x, y - 1) : new Pair(-1, -1);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        neighbors[1] = allowed(x + 1, y) ? new Pair(x + 1, y) : new Pair(-1, -1);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">        neighbors[2] = allowed(x, y + 1) ? new Pair(x, y + 1) : new Pair(-1, -1);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">        neighbors[3] = allowed(x - 1, y) ? new Pair(x - 1, y) : new Pair(-1, -1);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        neighbors[4] = allowed(x - 1, y - 1) ? new Pair(x - 1, y - 1) : new Pair(-1, -1);</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        neighbors[5] = allowed(x + 1, y - 1) ? new Pair(x + 1, y - 1) : new Pair(-1, -1);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        neighbors[6] = allowed(x + 1, y + 1) ? new Pair(x + 1, y + 1) : new Pair(-1, -1);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        neighbors[7] = allowed(x - 1, y + 1) ? new Pair(x - 1, y + 1) : new Pair(-1, -1);</span>

<span class="fc" id="L193">        return neighbors;</span>
    }

    private void addNeighbourNodes(Node currentNode) {
<span class="fc" id="L197">        int row = currentNode.getRow();</span>
<span class="fc" id="L198">        int col = currentNode.getColumn();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (row - 1 &gt;= 0) { //ylin rivi</span>
<span class="fc" id="L200">            checkNode(currentNode, col, row - 1, hCost); //upper</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            if (col - 1 &gt;= 0) {</span>
<span class="fc" id="L202">                checkNode(currentNode, col - 1, row - 1, diagonalCost); //upper left</span>
            }
<span class="fc bfc" id="L204" title="All 2 branches covered.">            if (col + 1 &lt; sr.getCols()) {</span>
<span class="fc" id="L205">                checkNode(currentNode, col + 1, row - 1, diagonalCost); //upper right</span>
            }
        }
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (col - 1 &gt;= 0) {</span>
<span class="fc" id="L209">            checkNode(currentNode, col - 1, row, hCost); //left</span>
        }
<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (col + 1 &lt; sr.getCols()) {</span>
<span class="fc" id="L212">            checkNode(currentNode, col + 1, row, hCost); //right</span>
        }
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (row + 1 &lt; sr.getRows()) { //lower row</span>
<span class="fc" id="L215">            checkNode(currentNode, col, row + 1, hCost); //bottom</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">            if (col - 1 &gt;= 0) {</span>
<span class="fc" id="L217">                checkNode(currentNode, col - 1, row + 1, diagonalCost); //bottom left</span>
            }
<span class="fc bfc" id="L219" title="All 2 branches covered.">            if (col + 1 &lt; sr.getCols()) {</span>
<span class="fc" id="L220">                checkNode(currentNode, col + 1, row + 1, diagonalCost); //bottom right</span>
            }
        }
<span class="fc" id="L223">    }</span>

    public Heap getOpenList() {
<span class="fc" id="L226">        return openList;</span>
    }

    @Override
    public CustomArrayList&lt;Node&gt; getClosedSet() {
<span class="fc" id="L231">        return closedSet;</span>
    }

    /**
     * Resets nodes, open list, closed set and path
     */
    public void reset() {
<span class="fc" id="L238">        sr.setNodes();</span>
<span class="fc" id="L239">        openList.clear();</span>
<span class="fc" id="L240">        closedSet.clear();</span>
<span class="fc" id="L241">        super.getPath().clear();</span>
<span class="fc" id="L242">    }</span>

    /**
     *
     * Calculates a heuristic from current to finalNode. The pattern may need
     * updating depending on input. The heuristic may yield wrong results if not
     * defined correctly.
     *
     * @param current Current node
     * @param finalNode Final node
     */
    public void calculateHeuristic(Node current, Node finalNode) {
<span class="fc" id="L254">        int manhattan = (int) (abs(finalNode.getColumn() - current.getColumn()) + abs(finalNode.getRow() - current.getRow()));</span>
<span class="fc" id="L255">        current.setH(manhattan);</span>
<span class="fc" id="L256">    }</span>

    /**
     *
     * Checks if a better path exists between currentNode and neighbour, and if
     * exists, updates neighbour's information.
     *
     * @param currentNode Current node
     * @param neighbour Neighbour node
     * @param cost Movement cost
     * @return true if a better path exists, false otherwise
     */
    public boolean checkifBetterPathExists(Node currentNode, Node neighbour, int cost) {
<span class="fc" id="L269">        int gCost = currentNode.getG() + cost;</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (gCost &lt; neighbour.getG()) {</span>
<span class="fc" id="L271">            neighbour.setAStarInformation(currentNode, cost);</span>
<span class="fc" id="L272">            return true;</span>
        }
<span class="fc" id="L274">        return false;</span>
    }

    /**
     * Gives an approximation of g value between two nodes.
     *
     * @param x1 x-coordinate of the first node
     * @param y1 y-coordinate of the first node
     * @param x2 x-coordinate of the second node
     * @param y2 y-coordinate of the second node
     *
     * @return Approximation of g cost
     */
    private int approxG(int x1, int y1, int x2, int y2) {
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (x1 == x2) {</span>
<span class="fc" id="L289">            return abs(y1 - y2) * hCost;</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        } else if (y1 == y2) {</span>
<span class="fc" id="L291">            return abs(x1 - x2) * hCost;</span>
        } else {
<span class="fc" id="L293">            return abs(x1 - x2) * diagonalCost;</span>
        }
    }

    public void setJPS(boolean b) {
<span class="fc" id="L298">        this.jps = b;</span>
<span class="fc" id="L299">    }</span>

    /**
     * Updates all Node informations in a range between currentNode and
     * jumpPoint. Used in JPS.
     *
     * @param currentNode Current Node
     * @param jumpPoint Jump point
     *
     */
    private void setAStarInformationRange(Node currentNode, Node jumpPoint) {
<span class="fc" id="L310">        int col1 = currentNode.getColumn();</span>
<span class="fc" id="L311">        int col2 = jumpPoint.getColumn();</span>
<span class="fc" id="L312">        int row1 = currentNode.getRow();</span>
<span class="fc" id="L313">        int row2 = jumpPoint.getRow();</span>
<span class="fc" id="L314">        int i = 0, j = 0;</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (col2 &lt; col1) {</span>
<span class="fc" id="L316">            i = -1;</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        } else if (col1 &lt; col2) {</span>
<span class="fc" id="L318">            i = 1;</span>
        }
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if (row2 &lt; row1) {</span>
<span class="fc" id="L321">            j = -1;</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        } else if (row1 &lt; row2) {</span>
<span class="fc" id="L323">            j = 1;</span>
        }

<span class="fc" id="L326">        int a = col1, b = row1;</span>
        while (true) {
<span class="fc" id="L328">            a += i;</span>
<span class="fc" id="L329">            b += j;</span>

<span class="fc" id="L331">            Node n = sr.getNodes()[b][a];</span>
<span class="fc" id="L332">            int newG = approxG(currentNode.getColumn(), currentNode.getRow(), n.getColumn(), n.getRow());</span>
<span class="fc bfc" id="L333" title="All 4 branches covered.">            if (n.getG() == 0 || currentNode.getG() + newG &lt; n.getG()) {</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">                if (!sr.isInitialNode(n)) {</span>
<span class="fc" id="L335">                    sr.getNodes()[b][a].setAStarInformation(currentNode, newG);</span>
                }
            }

<span class="fc bfc" id="L339" title="All 4 branches covered.">            if (a == col2 &amp;&amp; b == row2) {</span>
<span class="fc" id="L340">                break;</span>
            }
<span class="fc" id="L342">        }</span>
<span class="fc" id="L343">    }</span>

    public boolean getJps() {
<span class="fc" id="L346">        return jps;</span>
    }

    public void setClosedSet(CustomArrayList&lt;Node&gt; cs) {
<span class="fc" id="L350">        this.closedSet = cs;</span>
<span class="fc" id="L351">    }</span>

    private int abs(int a) {
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (a &lt; 0) {</span>
<span class="fc" id="L355">            return -a;</span>
        }
<span class="fc" id="L357">        return a;</span>
    }

    private int max(int a, int b) {
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (a &gt;= b) {</span>
<span class="fc" id="L362">            return a;</span>
        } else {
<span class="fc" id="L364">            return b;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>