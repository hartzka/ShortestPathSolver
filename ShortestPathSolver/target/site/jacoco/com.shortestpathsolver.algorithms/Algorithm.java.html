<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Algorithm.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ShortestPathSolver</a> &gt; <a href="index.source.html" class="el_package">com.shortestpathsolver.algorithms</a> &gt; <span class="el_source">Algorithm.java</span></div><h1>Algorithm.java</h1><pre class="source lang-java linenums">package com.shortestpathsolver.algorithms;

import com.shortestpathsolver.domain.Node;
import com.shortestpathsolver.domain.ShortestRoute;
import com.shortestpathsolver.structures.CustomArrayList;
import com.shortestpathsolver.structures.Pair;

/**
 * Abstract algorithm class. Contains implemented and unimplemented methods used
 * in algorithm classes.
 *
 * @author kaihartz
 */
public abstract class Algorithm {

    private ShortestRoute sr;
    private CustomArrayList&lt;Node&gt; finalPath;

<span class="fc" id="L19">    public Algorithm(ShortestRoute sr) {</span>
<span class="fc" id="L20">        this.sr = sr;</span>
<span class="fc" id="L21">        this.finalPath = new CustomArrayList&lt;&gt;();</span>
<span class="fc" id="L22">    }</span>

    /**
     * The main logic, which searches the shortest route
     *
     * @param initialNode Beginning of the search
     * @return List presenting the route
     */
    public abstract CustomArrayList&lt;Node&gt; calculatePath(Node initialNode);

    /**
     * Returns all allowed node's neighbours
     *
     * @param node
     * @return table presenting neighbours
     */
    public Pair&lt;Node, Integer&gt;[] getNeighbours(Node node) {
<span class="fc" id="L39">        Pair&lt;Node, Integer&gt;[] neighbors = new Pair[8];</span>
<span class="fc" id="L40">        int x = node.getColumn();</span>
<span class="fc" id="L41">        int y = node.getRow();</span>
<span class="fc" id="L42">        Node[][] nodes = sr.getNodes();</span>

<span class="fc bfc" id="L44" title="All 2 branches covered.">        neighbors[0] = allowed(x, y - 1) ? new Pair(nodes[y - 1][x], 10) : null;</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">        neighbors[1] = allowed(x + 1, y) ? new Pair(nodes[y][x + 1], 10) : null;</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">        neighbors[2] = allowed(x, y + 1) ? new Pair(nodes[y + 1][x], 10) : null;</span>
<span class="fc bfc" id="L47" title="All 2 branches covered.">        neighbors[3] = allowed(x - 1, y) ? new Pair(nodes[y][x - 1], 10) : null;</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">        neighbors[4] = allowed(x - 1, y - 1) ? new Pair(nodes[y - 1][x - 1], 14) : null;</span>
<span class="fc bfc" id="L49" title="All 2 branches covered.">        neighbors[5] = allowed(x + 1, y - 1) ? new Pair(nodes[y - 1][x + 1], 14) : null;</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">        neighbors[6] = allowed(x + 1, y + 1) ? new Pair(nodes[y + 1][x + 1], 14) : null;</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">        neighbors[7] = allowed(x - 1, y + 1) ? new Pair(nodes[y + 1][x - 1], 14) : null;</span>

<span class="fc" id="L53">        return neighbors;</span>
    }

    public CustomArrayList&lt;Node&gt; getPath(Node currentNode) {
<span class="fc" id="L57">        CustomArrayList&lt;Node&gt; path = new CustomArrayList&lt;&gt;();</span>
<span class="fc" id="L58">        path.add(currentNode);</span>
        Node parent;
<span class="fc bfc" id="L60" title="All 2 branches covered.">        while ((parent = currentNode.getParent()) != null) {</span>
<span class="fc" id="L61">            path.add(0, parent);</span>
<span class="fc" id="L62">            currentNode = parent;</span>
        }
<span class="fc" id="L64">        this.finalPath = path;</span>
<span class="fc" id="L65">        return path;</span>
    }

    public boolean allowed(int x, int y) {
<span class="fc bfc" id="L69" title="All 10 branches covered.">        return (x &lt; sr.getCols() &amp;&amp; y &lt; sr.getRows() &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; sr.getBlocks()[y][x] == false);</span>
    }

    public abstract CustomArrayList&lt;Node&gt; getClosedSet();

    public CustomArrayList&lt;Node&gt; getPath() {
<span class="fc" id="L75">        return this.finalPath;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>